<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°æ™ºçš„å°çƒæ¸¸æˆ - ä¿®å¤ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: white;
            font-family: 'Arial', sans-serif;
            user-select: none; /* é˜²æ­¢æ‹–æ‹½æ—¶é€‰ä¸­æ–‡æœ¬ */
        }
        h1 { margin-bottom: 10px; }
        p { margin-bottom: 20px; font-size: 14px; color: #bdc3c7; }
        .game-container {
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden; 
        }
        canvas {
            background-color: #27ae60;
            border: 20px solid #5d4037; 
            display: block;
            cursor: default; /* é»˜è®¤å…‰æ ‡ */
        }
        canvas:active {
            cursor: grabbing; /* æ‹–æ‹½æ—¶æŠ“æ‰‹å…‰æ ‡ */
        }
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #e67e22;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background 0.3s;
        }
        button:hover { background-color: #d35400; }
        #msg {
            height: 20px;
            color: #f1c40f;
            font-weight: bold;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <h1>ğŸ± å°æ™ºå°çƒå®¤ (ä¿®å¤æ‹–æ‹½)</h1>
    <p>æŒ‰ä½ç™½çƒå‘åæ‹‰ï¼Œæ¾å¼€é¼ æ ‡å‘å°„ï¼</p>
    
    <div class="game-container">
        <canvas id="poolTable" width="800" height="400"></canvas>
    </div>
    <div id="msg"></div>
    
    <div class="controls">
        <button onclick="resetGame()">é‡ç½®æ¸¸æˆ</button>
    </div>

<script>
    const canvas = document.getElementById('poolTable');
    const ctx = canvas.getContext('2d');
    const msgDiv = document.getElementById('msg');

    // ç‰©ç†å‚æ•°
    const FRICTION = 0.985; 
    const BALL_RADIUS = 12;
    const POCKET_RADIUS = 25; // ç¨å¾®åŠ å¤§ä¸€ç‚¹æ´å£ï¼Œæ›´å®¹æ˜“è¿›
    
    // æ¸¸æˆçŠ¶æ€
    let isDragging = false;
    let balls = [];
    let whiteBall = null; // å•ç‹¬å­˜å‚¨ç™½çƒå¼•ç”¨ï¼Œæ–¹ä¾¿æŸ¥æ‰¾
    let currentMouseX = 0;
    let currentMouseY = 0;

    // å®šä¹‰6ä¸ªæ´çš„ä½ç½® (åæ ‡ç›¸å¯¹äºcanvaså†…éƒ¨)
    const pockets = [
        { x: 0, y: 0 },
        { x: 400, y: 0 },
        { x: 800, y: 0 },
        { x: 0, y: 400 },
        { x: 400, y: 400 },
        { x: 800, y: 400 }
    ];

    class Ball {
        constructor(x, y, color, isWhite = false) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.color = color;
            this.isWhite = isWhite;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.closePath();

            // é«˜å…‰
            ctx.beginPath();
            ctx.arc(this.x - 3, this.y - 3, BALL_RADIUS / 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fill();
            ctx.closePath();
        }

        update() {
            // å¦‚æœæ­£åœ¨æ‹–æ‹½ç™½çƒï¼Œç™½çƒä¸åº”è¯¥ç§»åŠ¨ï¼ˆé˜²æ­¢è¿˜æ²¡å‘å°„å°±åŠ¨äº†ï¼‰
            if (this.isWhite && isDragging) return;

            this.x += this.vx;
            this.y += this.vy;
            this.vx *= FRICTION;
            this.vy *= FRICTION;

            if (Math.abs(this.vx) < 0.05) this.vx = 0;
            if (Math.abs(this.vy) < 0.05) this.vy = 0;

            // ç®€å•çš„å¢™å£åå¼¹ï¼ˆè¾…åŠ©è¿›æ´åˆ¤å®šï¼Œé˜²æ­¢ç©¿å¢™ï¼‰
            // åªæœ‰å½“çƒä¸åœ¨æ´å£é™„è¿‘æ—¶æ‰åå¼¹ï¼Œå¦åˆ™æ— æ³•è¿›æ´
            // è¿™é‡Œåšä¸€ä¸ªç®€åŒ–çš„å¤„ç†ï¼šç›´æ¥åå¼¹ï¼Œè¿›æ´é€»è¾‘åœ¨ checkPockets è¦†ç›–
            if (this.x - BALL_RADIUS < 0) { this.x = BALL_RADIUS; this.vx = -this.vx; }
            if (this.x + BALL_RADIUS > canvas.width) { this.x = canvas.width - BALL_RADIUS; this.vx = -this.vx; }
            if (this.y - BALL_RADIUS < 0) { this.y = BALL_RADIUS; this.vy = -this.vy; }
            if (this.y + BALL_RADIUS > canvas.height) { this.y = canvas.height - BALL_RADIUS; this.vy = -this.vy; }
        }
    }

    function initGame() {
        balls = [];
        msgDiv.innerText = "";
        
        // åˆ›å»ºç™½çƒ
        whiteBall = new Ball(200, 200, 'white', true);
        balls.push(whiteBall);

        // å½©çƒæ‘†æ”¾
        let startX = 550;
        let startY = 200;
        
        balls.push(new Ball(startX, startY, 'red'));
        balls.push(new Ball(startX + 25, startY - 13, 'yellow'));
        balls.push(new Ball(startX + 25, startY + 13, 'blue'));
        balls.push(new Ball(startX + 50, startY - 26, 'purple'));
        balls.push(new Ball(startX + 50, startY, 'black')); 
        balls.push(new Ball(startX + 50, startY + 26, 'orange'));
        balls.push(new Ball(startX + 75, startY - 39, 'green'));
        balls.push(new Ball(startX + 75, startY - 13, 'brown'));
        balls.push(new Ball(startX + 75, startY + 13, 'pink'));
        balls.push(new Ball(startX + 75, startY + 39, 'maroon'));
    }

    function drawPockets() {
        ctx.fillStyle = '#111';
        pockets.forEach(pocket => {
            ctx.beginPath();
            ctx.arc(pocket.x, pocket.y, POCKET_RADIUS, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function checkCollisions() {
        for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
                let b1 = balls[i];
                let b2 = balls[j];
                let dx = b2.x - b1.x;
                let dy = b2.y - b1.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < BALL_RADIUS * 2) {
                    let angle = Math.atan2(dy, dx);
                    let sin = Math.sin(angle);
                    let cos = Math.cos(angle);

                    // æ—‹è½¬é€Ÿåº¦
                    let vx1 = b1.vx * cos + b1.vy * sin;
                    let vy1 = b1.vy * cos - b1.vx * sin;
                    let vx2 = b2.vx * cos + b2.vy * sin;
                    let vy2 = b2.vy * cos - b2.vx * sin;

                    // äº¤æ¢é€Ÿåº¦
                    let vx1Final = vx2;
                    let vx2Final = vx1;

                    // ä¿®æ­£é‡å ä½ç½®
                    let overlap = BALL_RADIUS * 2 - distance;
                    let moveX = (overlap / 2) * cos;
                    let moveY = (overlap / 2) * sin;
                    
                    b1.x -= moveX;
                    b1.y -= moveY;
                    b2.x += moveX;
                    b2.y += moveY;

                    // è½¬å›åŸåæ ‡ç³»
                    b1.vx = vx1Final * cos - vy1 * sin;
                    b1.vy = vy1 * cos + vx1Final * sin;
                    b2.vx = vx2Final * cos - vy2 * sin;
                    b2.vy = vy2 * cos + vx2Final * sin;
                }
            }
        }
    }

    function checkPockets() {
        for (let i = balls.length - 1; i >= 0; i--) {
            let ball = balls[i];
            
            // åªæœ‰å½“çƒåœ¨ç§»åŠ¨æ—¶æ‰æ£€æµ‹è¿›æ´ï¼Œé˜²æ­¢é™æ€è¯¯åˆ¤
            // æˆ–è€…çƒç¦»æ´å£éå¸¸è¿‘
            let inPocket = false;
            for (let pocket of pockets) {
                let dx = ball.x - pocket.x;
                let dy = ball.y - pocket.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                // åˆ¤å®šè·ç¦»ç¨å¾®æ”¾å®½
                if (dist < POCKET_RADIUS) {
                    inPocket = true;
                    break;
                }
            }

            if (inPocket) {
                if (ball.isWhite) {
                    msgDiv.innerText = "ğŸ˜± ç™½çƒè¿›æ´ï¼çŠ¯è§„ï¼";
                    ball.vx = 0;
                    ball.vy = 0;
                    ball.x = 200;
                    ball.y = 200;
                    isDragging = false; // è¿›æ´åå¼ºåˆ¶åœæ­¢æ‹–æ‹½çŠ¶æ€
                } else {
                    balls.splice(i, 1);
                    if (balls.length === 1 && balls[0].isWhite) {
                         msgDiv.innerText = "ğŸ‰ æ­å–œï¼æ¸…å°æˆåŠŸï¼";
                    }
                }
            }
        }
    }

    // --- é¼ æ ‡äº‹ä»¶ä¿®å¤ ---

    // è·å–é¼ æ ‡åœ¨Canvaså†…çš„åæ ‡
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    canvas.addEventListener('mousedown', (e) => {
        const pos = getMousePos(e);
        
        // åªæœ‰å½“ç™½çƒå‡ ä¹é™æ­¢æ—¶æ‰èƒ½æ‹–æ‹½
        if (Math.abs(whiteBall.vx) < 0.1 && Math.abs(whiteBall.vy) < 0.1) {
            let dist = Math.sqrt((pos.x - whiteBall.x)**2 + (pos.y - whiteBall.y)**2);
            
            // æ‰©å¤§ä¸€ç‚¹ç‚¹å‡»èŒƒå›´ï¼Œæ–¹ä¾¿æ“ä½œ (åŠå¾„çš„2å€)
            if (dist < BALL_RADIUS * 2.5) {
                isDragging = true;
                msgDiv.innerText = "";
                // è®°å½•å½“å‰é¼ æ ‡ä½ç½®ç”¨äºç”»çº¿
                currentMouseX = pos.x;
                currentMouseY = pos.y;
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        const pos = getMousePos(e);
        currentMouseX = pos.x;
        currentMouseY = pos.y;
        
        // æ”¹å˜é¼ æ ‡æ ·å¼æç¤ºç”¨æˆ·
        if (!isDragging) {
            let dist = Math.sqrt((pos.x - whiteBall.x)**2 + (pos.y - whiteBall.y)**2);
            if (dist < BALL_RADIUS * 2.5 && Math.abs(whiteBall.vx) < 0.1) {
                canvas.style.cursor = "pointer";
            } else {
                canvas.style.cursor = "default";
            }
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        
        // è®¡ç®—åŠ›åº¦å‘é‡ï¼šä»é¼ æ ‡ä½ç½®æŒ‡å‘ç™½çƒä½ç½®ï¼ˆåå‘æ‹‰å¼“ï¼‰
        let forceX = whiteBall.x - currentMouseX;
        let forceY = whiteBall.y - currentMouseY;
        
        // é™åˆ¶æœ€å¤§åŠ›åº¦
        const MAX_FORCE = 200;
        let forceMag = Math.sqrt(forceX**2 + forceY**2);
        
        if (forceMag > MAX_FORCE) {
            let scale = MAX_FORCE / forceMag;
            forceX *= scale;
            forceY *= scale;
        }

        // å‘å°„ï¼
        // å¢åŠ ä¸€ç‚¹åŠ›åº¦ç³»æ•°ï¼Œè®©çƒè·‘å¾—å¿«ç‚¹
        whiteBall.vx = forceX * 0.15;
        whiteBall.vy = forceY * 0.15;

        isDragging = false;
        canvas.style.cursor = "default";
    });

    // è§¦æ‘¸å±æ”¯æŒ (æ‰‹æœºä¹Ÿèƒ½ç©)
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;

        if (Math.abs(whiteBall.vx) < 0.1 && Math.abs(whiteBall.vy) < 0.1) {
            let dist = Math.sqrt((touchX - whiteBall.x)**2 + (touchY - whiteBall.y)**2);
            if (dist < BALL_RADIUS * 3) {
                isDragging = true;
                currentMouseX = touchX;
                currentMouseY = touchY;
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if(!isDragging) return;
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        currentMouseX = touch.clientX - rect.left;
        currentMouseY = touch.clientY - rect.top;
    }, {passive: false});

    canvas.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        // é€»è¾‘åŒ mouseup
        let forceX = whiteBall.x - currentMouseX;
        let forceY = whiteBall.y - currentMouseY;
        const MAX_FORCE = 200;
        let forceMag = Math.sqrt(forceX**2 + forceY**2);
        if (forceMag > MAX_FORCE) {
            let scale = MAX_FORCE / forceMag;
            forceX *= scale;
            forceY *= scale;
        }
        whiteBall.vx = forceX * 0.15;
        whiteBall.vy = forceY * 0.15;
        isDragging = false;
    });


    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawPockets();

        // ç”»ç„å‡†çº¿ (åªæœ‰æ‹–æ‹½æ—¶æ‰ç”»)
        if (isDragging) {
            ctx.beginPath();
            ctx.moveTo(whiteBall.x, whiteBall.y);
            ctx.lineTo(currentMouseX, currentMouseY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 4;
            ctx.setLineDash([5, 5]); // è™šçº¿
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ç”»ä¸€ä¸ªåŠ›åº¦æŒ‡ç¤ºåœ†
            ctx.beginPath();
            ctx.arc(whiteBall.x, whiteBall.y, Math.sqrt((whiteBall.x-currentMouseX)**2 + (whiteBall.y-currentMouseY)**2), 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        checkPockets();

        balls.forEach(ball => {
            ball.update();
            ball.draw();
        });

        checkCollisions();

        requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        initGame();
    }

    initGame();
    gameLoop();

</script>
</body>
</html>
